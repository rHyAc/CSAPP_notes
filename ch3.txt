Registers
	63                                31                15        7    0
	   %rax                              %eax              %ax      %al  
	   %r8                               %r8d              %r8w     %r8b
	                                     —— d for double word       
	   
The remaining bytes in the register for instructions that generate less than 8 bytes:
	1. instructions that generate 1-or 2-byte quantities leave the remaining bytes unchanged
	2. instructions that generate 4-byte quantities set the upper 4 bytes of the register to zero

AT&T assembly format addressing modes
	Imm(rb, ri, s): Imm + R[rb] + R[ri] * s
		1. s must be 1, 2, 4, or 8
		2. rb and ri must be 64-bit registers
		3. Imm is signed

Instructions
	mov instructions
		cannot have both operands refer to memory locations
	movq 
		only have immediate source operands that can be represented as 32-bit two'scomplement numbers,
		this value is then sign extended to produce the 64-bit value for the destination.
	movabsq 
		can have an arbitrary 64-bit immediate value as its source operand 
		and can only have a register as a destination
	
	cltq(has no operands)
		sign-extend %eax to %rax
		
	movzlq does not exist, because movl have the same effect
	
	pushq S
		R[%rsp] ← R[%rsp] –8
		M[R[%rsp]] ← S
	popq D
		D ← M[R[%rsp]];
		D ← M[R[%rsp]];
		
	leaq S, D
		1. D ← &S
		2. can be used to compactly describe common arithmetic operations
		   e.g.
			@register %rdx contains value x, set register %rax to 5x + 7
			leaq 7(%rdx,%rdx,4), %rax
			
	add, subb, imul(one form), xor, or, and
		1. two operands cannot both be memory locations
		2. when the second operand is a memory location, the processor must read the value from memory,
		   perform the operation, and then write the result back to memory
		   
	shift instructions
		can specify the shift amount  either as an immediate value or with the low m bits 
		in the single-byte register %cl, where 2 ^ m less than the bit length of the value to shift
	
	imulq S(the other form)
		1. R[%rdx]:R[ %rax ] ← S * R[%rax]
		2. signed full multiply
	mulq S
		1. R[%rdx]:R[%rax] ← S * R[%rax]
		2. unsigned full multiply
	cqto
		1. R[%rdx]:R[%rax] ← SignExtend(R[%rax])
		2. convert to oct word, needed before div instructions
	idivq S
		1. R[%rdx] ← R[%rdx]:R[%rax] % S;
		   R[%rax] ← R[%rdx]:R[%rax] / S
		2. signed divide
	divq S
		1. R[%rdx] ← R[%rdx]:R[%rax] % S;
		   R[%rax] ← R[%rdx]:R[%rax] / S
		2. unsigned divide
	—— S can't be Imm
	
	cmp(s2, s1) instructions
		s1 - s2
	test(s2, s1) instructions
		s1 & s2
	
	set instructions
		has either one of the low-order single-byte register elements or a single-byte memory location 
		as its destination, setting a single byte to 0 or to 1 depending on some combination of 
		the condition codes
	sete/setz D
		D ← ZF, equal / zero
	setne/setnz D  
		D ← ~ZF, not equal / not zero
	sets D 
		D ← SF, egative
	setns D 
		D ← ~SF, nonnegative
	setg/setnle D  
		D ← ~(SF ^ OF) & ~ZF, greater (signed >)
	setge/setnl D  
		D ← ~ (SF ^ OF), greater or equal (signed>=)
	setl/setnge D  
		D ← SF ^ OF, less (signed <)
	setle/setng D  
		D ← (SF ^ OF) | ZF, less or equal (signed <=)
	seta/setnbe D  
		D ← ~CF & ~ ZF, above (unsigned >)
	setae/setnb D  
		D ← ~CF, above or equal (unsigned >=)
	setb/setnae D  
		D ← CF, below (unsigned <)
	setbe/setna D  
		D ← CF | ZF, below or equal (unsigned <=)
		
	jmp/call
		1. direct jumps/calls are written in assembly code by giving a label(or Imm) as the target
		2. Indirect jumps/calls are written using '*' followed by an operand specifier using a register 
		   or a memory location where the target is stored 
	
	cmov(z, nz, s, ns, g, le...) instructions
		1. transfer the data from the source register or memory location to the destination register, 
		   only when the condition specified by the suffix holds
		2. the source and destination values can be 16, 32, or 64 bits long
	
Condition registers
	CF: Carry flag. The most recent operation generated a carry out of the most significant bit. 
	    Used to detect overflow for unsignedoperations.
	ZF: Zero flag. The most recent operation yielded zero.
	SF: Sign flag. The most recent operation yielded a negative value.
	OF: Overflow flag. The most recent operation caused a two'scomplement overflow—either negative or positive.
	
	1. leaq does not alter any condition codes
	2. For the logical operations, the carry and overflow flags are set to zero
	3. For the shift operations, the carry flag is set to the last bit shifted out, 
	   while the overflow flag is set to zero
	4. the inc and dec instructions set the overflow and zero flags, but they leave the carry flag unchanged

Pass arguments
	1. . when passing parameters on the stack, each argument size is rounded up to be multiples of eight bytes
